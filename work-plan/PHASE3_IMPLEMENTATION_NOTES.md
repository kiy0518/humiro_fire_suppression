# Phase 3 구현 노트

## 현재 상황 분석

### Phase 3의 목표
제안서에서는 "모든 계층 간 통신을 ROS2 토픽으로 전환"을 목표로 하고 있지만, 실제 구현 시 고려사항:

1. **성능 요구사항**: 
   - 현재 시스템은 30 FPS 실시간 스트리밍
   - ROS2 토픽 오버헤드는 무시할 수 없음

2. **현재 구조**:
   - thermal/src/main.cpp는 순수 C++ 애플리케이션
   - ROS2 없이 실행 가능 (독립 실행 파일)
   - 내부 통신은 ThreadSafeQueue 사용 (고성능)

3. **LiDAR 상태**:
   - lidar/src는 현재 ROS2를 사용하지 않는 것으로 보임
   - 독립 C++ 라이브러리

## 권장 접근법

### 옵션 A: 점진적 접근 (권장)
**현재 구조 유지 + ROS2 토픽 발행 추가**

- 내부 통신: 기존 큐 방식 유지 (성능)
- 외부 접근: ROS2 토픽 발행 (모니터링/디버깅)
- 장점:
  - 성능 영향 최소화
  - 점진적 전환 가능
  - 기존 코드 유지
- 구현:
  - main.cpp에 ROS2 노드 추가 (선택적)
  - 각 계층에서 ROS2 토픽 발행
  - ROS2 기능은 컴파일 옵션으로 제어

### 옵션 B: 완전 분리
**각 계층을 독립 ROS2 노드로**

- 모든 통신을 ROS2 토픽으로
- 장점: 완전한 모듈화
- 단점: 성능 오버헤드, 복잡도 증가

## Phase 3 재정의 제안

### 단계 1: ROS2 토픽 발행 추가 (점진적)
1. main.cpp에 ROS2 노드 래퍼 추가 (선택적 컴파일)
2. thermal 데이터를 ROS2 토픽으로 발행 (`/thermal/data`, `/thermal/image`)
3. lidar 데이터를 ROS2 토픽으로 발행 (`/lidar/points`, `/lidar/front_distance`)
4. 타겟팅 결과를 ROS2 토픽으로 발행 (`/targeting/image`)

### 단계 2: ROS2 메시지 타입 정의
- 커스텀 메시지 타입 정의 (필요시)
- 또는 표준 메시지 타입 사용

### 단계 3: 외부 노드와의 통합
- 다른 ROS2 노드에서 데이터 구독 가능
- 모니터링, 로깅, 디버깅 용도

## 구현 우선순위

**현재로서는 Phase 3를 완전히 구현하기보다는:**

1. **기반 구조 마련** (현재 단계)
   - ROS2 패키지 구조 설계
   - 메시지 타입 정의
   - 컴파일 옵션 추가

2. **선택적 구현** (필요시)
   - ROS2 토픽 발행 기능 추가
   - 컴파일 옵션으로 제어

3. **완전 전환** (향후)
   - 모든 통신을 ROS2로 전환 (성능 검증 후)

## 결론

Phase 3는 **대규모 리팩토링**이 필요하며, 성능에 영향을 줄 수 있습니다.

**제안:**
- Phase 3는 현재로서는 "계획 단계"로 두고
- 실제 구현은 성능 요구사항과 사용자 요구를 고려하여 결정
- 대신 **Phase 4 (테스트 및 검증)**에 집중하는 것을 권장

또는

- **최소 구현**: ROS2 토픽 발행만 추가 (내부 통신은 유지)
- 컴파일 옵션으로 제어
- 필요시 활성화

어떤 방향으로 진행할지 사용자와 상의 필요.

