import cv2
import numpy as np
import wiringpi as GPIO
from screeninfo import get_monitors
import atexit  # 추가

monitor = get_monitors()[0]
screen_width = monitor.width
screen_height = monitor.height

logo = cv2.imread('/home/khadas/Thermal_RGB/easy_logo_alpha.png', cv2.IMREAD_UNCHANGED)  # .png 파일은 투명도 정보가 포함될 수 있습니다.

desired_logo_width = 240  # 원하는 로고의 폭
scale_factor = desired_logo_width / logo.shape[1]
logo_resized = cv2.resize(logo, (int(logo.shape[1] * scale_factor), int(logo.shape[0] * scale_factor)))



# 창 이름을 설정하고 전체화면으로 설정
cv2.namedWindow('Overlay', cv2.WND_PROP_FULLSCREEN)
cv2.setWindowProperty('Overlay', cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)

INPUT = 0
OUTPUT = 1
OUTPUT_PIN = 17
INPUT_PIN = 16
OUTPUT_HIGH = 1
OUTPUT_LOW = 0

GPIO.wiringPiSetup()
# wiringpi.wiringPiSetupSys()
# wiringpi.wiringPiSetupGpio()
GPIO.pinMode(INPUT_PIN, INPUT)
GPIO.pinMode(OUTPUT_PIN, OUTPUT)
# GPIO를 초기화하는 부분 아래에 이 함수를 추가합니다.
def cleanup_gpio():
    GPIO.digitalWrite(OUTPUT_PIN, OUTPUT_LOW)  # OUTPUT_PIN을 low로 설정

atexit.register(cleanup_gpio)  # 프로그램 종료 시 cleanup_gpio 함수 호출

def overlay_transparent(background, overlay_image, x, y):
    h, w, _ = overlay_image.shape
    
    if overlay_image.shape[2] == 4:  # 투명도 채널이 있는 경우
        overlay_alpha = overlay_image[:, :, 3] / 255.0
        overlay_rgb = overlay_image[:, :, :3]
    else:  # 투명도 채널이 없는 경우
        overlay_alpha = np.ones(overlay_image.shape[:2])
        overlay_rgb = overlay_image

    background_alpha = 1.0 - overlay_alpha

    for c in range(0, 3):
        background[y:y+h, x:x+w, c] = overlay_alpha * overlay_rgb[:, :, c] + background_alpha * background[y:y+h, x:x+w, c]

    return background

def add_shadow(logo, shadow_offset=(5,5), blur_amount=(15,15)):
    # 로고의 복사본을 생성하고 검은색으로 채웁니다.
    shadow = np.zeros_like(logo)
    shadow[...,:3] = 0
    shadow[..., 3] = logo[..., 3]

    # 블러 처리를 적용합니다.
    shadow = cv2.GaussianBlur(shadow, blur_amount, 0)

    # 그림자와 로고의 크기를 조정합니다.
    h, w, _ = logo.shape
    result = np.zeros((h + shadow_offset[1], w + shadow_offset[0], 4), dtype=logo.dtype)

    # 그림자를 결과 이미지에 추가합니다.
    result[shadow_offset[1]:, shadow_offset[0]:] += shadow

    # 원본 로고를 결과 이미지에 추가합니다.
    result[:h, :w] += logo

    return result


def check_camera_connection(cap):
    '''카메라 연결 상태를 확인합니다.'''
    if cap is None or not cap.isOpened():
        return False
    else:
        _, frame = cap.read()
        return frame is not None

def draw_marker(frame, center, radius_outer, radius_inner, color):
    frame = cv2.circle(frame, center, 10, color, 1)
    frame = cv2.circle(frame, center, radius_outer, color, 1)
    frame = cv2.circle(frame, center, radius_inner, color, 1)

    extend_radius = radius_outer + 20
    # frame = cv2.line(frame, (center[0] - extend_radius, center[1]),
    #                  (center[0] + extend_radius, center[1]), color, 2)
    # frame = cv2.line(frame, (center[0], center[1] - extend_radius),
    #                  (center[0], center[1] + extend_radius), color, 2)

    frame = cv2.line(frame, (center[0]+10, center[1]),
                     (center[0] + extend_radius, center[1]), color, 2)
    frame = cv2.line(frame, (center[0] - extend_radius, center[1]),
                     (center[0]-10, center[1]), color, 2)

    frame = cv2.line(frame, (center[0], center[1] + 10),
                     (center[0], center[1] + extend_radius), color, 2)
    frame = cv2.line(frame, (center[0], center[1]-10),
                     (center[0], center[1] - extend_radius), color, 2)

    return frame

desired_rgb_width = 640  # 원하는 폭 설정
desired_rgb_height = 480   # 원하는 높이 설정

cap1 = cv2.VideoCapture(2)  #Thermal
cap2 = cv2.VideoCapture(0)  #RGB

cap2.set(cv2.CAP_PROP_FRAME_WIDTH, desired_rgb_width)
cap2.set(cv2.CAP_PROP_FRAME_HEIGHT, desired_rgb_height)

if not cap1.isOpened() or not cap2.isOpened():
    print("Cannot open one or both cameras")
    exit()

scale = 0.75
thermal_width, thermal_height = int(640*scale), int(480*scale)
thermal_dx, thermal_dy = 0, -10

rgb_width, rgb_height = 640, 480
cut_pixels = 30

x_pos, y_pos = int(((rgb_width - thermal_width) / 2)+thermal_dx), int(
    min((rgb_height - thermal_height) / 2 + thermal_dy, rgb_height - thermal_height+cut_pixels))


alpha_thermal_layer = 0.6
alpha_marker_layer = 0.0

center = (thermal_width // 2, thermal_height // 2)
radius_outer = 100
radius_inner = 50

while True:


        # 카메라 연결 확인
    if not check_camera_connection(cap1):
        cap1.release()
        cap1 = cv2.VideoCapture(2)
    if not check_camera_connection(cap2):
        cap2.release()
        cap2 = cv2.VideoCapture(0)
        
        
    ret1, frame1 = cap1.read()
    ret2, frame2 = cap2.read()
    input = GPIO.digitalRead(INPUT_PIN)

    # if input==1:
    #     print("HIGH")
    # else: print("LOW")
    
    if not ret1 or not ret2:
        print("Can't receive frame (stream end?). Exiting ...")
        break

    frame1_resized = cv2.resize(frame1, (thermal_width, thermal_height))

    frame1_cropped = frame1_resized[:-cut_pixels, :]

    green = frame1_cropped[:, :, 1]

    kernel = np.ones((1, 1), dtype=np.float32) / 1
    green_avg = cv2.filter2D(green, -1, kernel)

    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(green)

    distance_to_max = np.sqrt(
        (center[0] - max_loc[0])**2 + (center[1] - max_loc[1])**2)
    if (distance_to_max < radius_inner)&(input ==1):

        color = (0, 255, 0)
        max_loc_color = (0, 255, 0)
        GPIO.digitalWrite(OUTPUT_PIN, OUTPUT_HIGH)
    elif distance_to_max < radius_outer:
        color = (0, 255, 255)
        max_loc_color = (0, 255, 255)
        GPIO.digitalWrite(OUTPUT_PIN, OUTPUT_LOW)
    else:
        color = (255, 255, 255)
        max_loc_color = (0, 0, 255)
        GPIO.digitalWrite(OUTPUT_PIN, OUTPUT_LOW)
    overlay_marker = draw_marker(
        np.zeros_like(frame1_cropped), center, radius_outer, radius_inner, color)
    overlay_marker = cv2.circle(overlay_marker, max_loc, 20, max_loc_color, 2)

    # Crop RGB image to match thermal image size
    frame2_cropped = frame2[y_pos:y_pos+thermal_height -
                            cut_pixels, x_pos:x_pos+thermal_width]

    overlay_area = cv2.addWeighted(
        frame2_cropped, alpha_thermal_layer, frame1_cropped, 1 - alpha_thermal_layer, 0)

    # Create mask
    mask = overlay_marker.any(axis=2)

    # Adjust transparency of marker line
    overlay_area = \
        np.where(mask[:, :, np.newaxis],
                 np.float32(overlay_area)*alpha_marker_layer +
                 np.float32(overlay_marker)*(1 - alpha_marker_layer),
                 overlay_area).astype(np.uint8)

    # Add max_loc text
    # Compute relative position to the center
    relative_loc = (max_loc[0] - center[0], max_loc[1] - center[1])
    relative_loc_str = "(dx, dy): ({}, {})".format(
        relative_loc[0], relative_loc[1])
    cv2.putText(overlay_area, relative_loc_str, (11, 21),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)
    cv2.putText(overlay_area, relative_loc_str, (10, 20),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
# Add max_val text
    max_val_str = "Max raw value: {:.1f}".format(max_val)
    cv2.putText(overlay_area, max_val_str, (11, 41),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 2)
    cv2.putText(overlay_area, max_val_str, (10, 40),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

    # 원본 영상의 비율 계산
    original_aspect = overlay_area.shape[1] / overlay_area.shape[0]

    # 화면 크기를 기반으로 새로운 크기를 계산
    new_width = screen_width
    new_height = int(screen_width / original_aspect)

    if new_height > screen_height:
        new_height = screen_height
        new_width = int(screen_height * original_aspect)

    overlay_area_resized = cv2.resize(overlay_area, (new_width, new_height))

    # 로고를 상단 중앙에 배치하기 위한 위치 계산
    overlay_x_pos = (overlay_area_resized.shape[1] - logo_resized.shape[1])-20
    overlay_y_pos = 20
    print(logo_resized.shape)

    # 1. frame1_cropped를 4 채널 이미지로 변환
    if frame1_cropped.shape[2] == 3:  # BGR format
        frame1_cropped = cv2.cvtColor(frame1_cropped, cv2.COLOR_BGR2BGRA)  # Convert to BGRA format

    # 2. THRESHOLD_VALUE와 cv2.threshold()를 올바르게 사용
    THRESHOLD_VALUE = 0
    _, thresholded = cv2.threshold(green_avg.astype(np.uint8), THRESHOLD_VALUE, 255, cv2.THRESH_BINARY)

    # 임계치 이하의 값은 투명하게 처리
    frame1_cropped[thresholded == 0] = [0, 0, 0, 0]  # R, G, B, Alpha
    

    overlay_transparent(overlay_area_resized, logo_resized, overlay_x_pos, overlay_y_pos)
    cv2.imshow('Overlay', overlay_area_resized)

    if cv2.waitKey(1) == ord('q'):
        break

cap1.release()
cap2.release()
cv2.destroyAllWindows()


